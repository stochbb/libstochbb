<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>libstochbb - Stochastic Building Blocks: Application programming interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstochbb - Stochastic Building Blocks
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Assemble arbitrary samplers.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Application programming interface </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The application programming interface (API) allows to assemble processes programmatically in C++.</p>
<p>All API classes are derived from the <code><a class="el" href="classsbb_1_1_container.html" title="Base class of all container classes. ">sbb::Container</a></code> class which is an essential part of the memory management system used by StochBB. Usually the C++ programmer needs to keep track of all objects still in use and is responsibe to free unneeded objects to avoid memory leaks. This can be a difficult taks when dealing with complex structured objects cross referencing eachother. To ease the usage of StochBB, a mark and sweep garbage colector is implemened which keeps track of all objects being directly or indirectly reachable and freeing all unreachable objects. For this memory management system to work, it is necessary to treat all container like values although they represent references to objects allocated on the heap.</p>
<p>The central class of StochBB is <code><a class="el" href="classsbb_1_1_var.html" title="Base class of all random variables. ">sbb::Var</a></code>, representing a random variable. This could be a simple random variable having a specified distribution (see <code><a class="el" href="classsbb_1_1_atomic_var.html" title="A generic random variable derived from a chosen density. ">sbb::AtomicVar</a></code>) or a random variable that is derived from others like <code><a class="el" href="classsbb_1_1_chain.html" title="Implements the sum of the independent random variables , . ">sbb::Chain</a></code>, <code><a class="el" href="classsbb_1_1_minimum.html" title="Implements the minimum of the  independent random variables , . ">sbb::Minimum</a></code>, <code><a class="el" href="classsbb_1_1_maximum.html" title="Implements the maximum of the  independent random variables , . ">sbb::Maximum</a></code> or <code><a class="el" href="classsbb_1_1_mixture.html" title="This class implements a mixture of random variables. ">sbb::Mixture</a></code>. All random variables have probability density function attached. You can access it using the <code><a class="el" href="classsbb_1_1_var.html#a48f76f51ec00f7c80da8a7a0c4d048ad" title="Returns a reference to the density associated with this random variable. ">sbb::Var::density</a></code> method which returns a <code><a class="el" href="classsbb_1_1_density.html" title="Base class of all densities (PDFs). ">sbb::Density</a></code> object.</p>
<p>All <code><a class="el" href="classsbb_1_1_density.html" title="Base class of all densities (PDFs). ">sbb::Density</a></code> objects have two methods, <code><a class="el" href="classsbb_1_1_density.html#aa4fe46640ba9b1026eb5808ebcd76d68" title="Evaluates the density (PDF) on a regular grid  where the number of grid points is specified via the l...">sbb::Density::eval</a></code> evaluating the probability density function and <code><a class="el" href="classsbb_1_1_density.html#a2fce828b6f339bdc6ebcc209ac254b64" title="Evaluates the probability function (CDF) on a regular grid  where the number of grid points is specif...">sbb::Density::evalCDF</a></code> evaluating the cumulative density or probability function. Assembling a system of random variables and evaluate their PDFs or CDFs is straight forward. Sampling, however, is not that trivial and is described below in some detail.</p>
<h1><a class="anchor" id="apirv"></a>
Assembling random processes</h1>
<p>In a first step, one may define a new gamma-distributed random variable with shape <img class="formulaInl" alt="$k=10$" src="form_24.png"/> and scale <img class="formulaInl" alt="$\theta=100$" src="form_25.png"/> as </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stochbb/api.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesbb.html">sbb</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X1 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(10, 100);</div>
</div><!-- fragment --><p>Its PDF can then be evaluated as on a regular grid in <img class="formulaInl" alt="$[0,1000)$" src="form_30.png"/> with 1000 grid points with </p><div class="fragment"><div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line">Eigen::VectorXd pdf(1000);</div>
<div class="line">X1.<a class="code" href="classsbb_1_1_var.html#a48f76f51ec00f7c80da8a7a0c4d048ad">density</a>().<a class="code" href="classsbb_1_1_density.html#aa4fe46640ba9b1026eb5808ebcd76d68">eval</a>(0, 1000, pdf);</div>
</div><!-- fragment --><p> The result of the evaluation is stored into the vector <code>pdf</code>. There are only very few basic or atomic random variable types defined in StochBB:</p>
<table class="doxtable">
<tr>
<th>Constructor </th><th>Parameters </th><th>Process description  </th></tr>
<tr>
<td><code><a class="el" href="classsbb_1_1_atomic_var.html#a58a2f93ef5a5be30abb569f96c42dc42" title="Constructs a delta-distributed &quot;random&quot; variable. ">sbb::AtomicVar::delta</a></code> </td><td>delay </td><td>A constant delay or a process with a fixed waiting time. </td></tr>
<tr>
<td><code><a class="el" href="classsbb_1_1_atomic_var.html#aa9db7fe860a9c35747c97747f3e7a3b0" title="Constructs a uniformly distributed random variable. ">sbb::AtomicVar::unif</a></code> </td><td>a, b </td><td>A process with a uniform-distributed waiting time. </td></tr>
<tr>
<td><code><a class="el" href="classsbb_1_1_atomic_var.html#a1ccaed48db2536303ebd24e59ca4d8c8" title="Constructs a normal distributed random variable. ">sbb::AtomicVar::norm</a></code> </td><td>mu, sigma </td><td>A process with a normal-distributed waiting. </td></tr>
<tr>
<td><code><a class="el" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480" title="Constructs a gamma distributed random variable. ">sbb::AtomicVar::gamma</a></code> </td><td>k, theta </td><td>A process with a gamma-distributed waiting time. </td></tr>
</table>
<p>More complex processes can be derived by combining atomic random variables.</p>
<h2><a class="anchor" id="apichain"></a>
Sums of random variables</h2>
<p>The most basic derived random variable is a <code><a class="el" href="classsbb_1_1_chain.html" title="Implements the sum of the independent random variables , . ">sbb::Chain</a></code>. This type represents the "chaining" of random processes. For example, given two random variables <img class="formulaInl" alt="$X_1$" src="form_2.png"/> and <img class="formulaInl" alt="$X_2$" src="form_3.png"/> and the random process <img class="formulaInl" alt="$X_1$" src="form_2.png"/> should trigger the next process <img class="formulaInl" alt="$X_2$" src="form_3.png"/>, the resulting random process <img class="formulaInl" alt="$Y$" src="form_14.png"/> can be desribed by the simple sum of the processes <img class="formulaInl" alt="$X_1$" src="form_2.png"/> and <img class="formulaInl" alt="$X_2$" src="form_3.png"/> as <img class="formulaInl" alt="$Y=X_1+X_2$" src="form_31.png"/>. That is, the time needed to complete both processes sequentially is simply the sum of the times needed for each process. Such a chain can be constructed using the overloaded <code>+</code> operator or the <code>sbb::chain</code> function. For example </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stochbb/api.hh&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesbb.html">sbb</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X1 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(10,100);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X2 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(20, 50);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> Y = X1 + X2;</div>
</div><!-- fragment --><h2><a class="anchor" id="apiminmax"></a>
Minimum and Maximum of random variables</h2>
<p>Another simple derived random variable is the <code><a class="el" href="classsbb_1_1_maximum.html" title="Implements the maximum of the  independent random variables , . ">sbb::Maximum</a></code> or <code><a class="el" href="classsbb_1_1_minimum.html" title="Implements the minimum of the  independent random variables , . ">sbb::Minimum</a></code> class. As the names suggest, they represent the maximum or minimum of a set of random variables. They can be created using the overloaded standard library function <code>std::min</code> and <code>std::max</code> or the <code>sbb::minimum</code> and <code>sbb::maximum</code> functions. The latter take a vector of random variables. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stochbb/api.hh&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesbb.html">sbb</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X1 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(10,100);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X2 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(20, 50);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> Y = std::max(X1, X2);</div>
</div><!-- fragment --><h2><a class="anchor" id="apimix"></a>
Mixtures of random variables</h2>
<p>Similar to the <code><a class="el" href="classsbb_1_1_minimum.html" title="Implements the minimum of the  independent random variables , . ">sbb::Minimum</a></code> or <code><a class="el" href="classsbb_1_1_maximum.html" title="Implements the maximum of the  independent random variables , . ">sbb::Maximum</a></code> a mixtrue of random variables can be constructed using the <code>sbb::mix</code> function. This function takes a vector of weights and a vector of corresponding random variables. Such a mixture can be considered as a random process which randomly selects the outcome of a set of other random processes, where the probability of selecting a specific process is given by the weight assigned to each process. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stochbb/api.hh&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesbb.html">sbb</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X1 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(10,100);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X2 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(20, 50);</div>
<div class="line"><span class="comment">// Assemble vector of variables</span></div>
<div class="line">std::vector&lt;Var&gt; vars; var.push_back(X1), vars.push_back(X2);</div>
<div class="line"><span class="comment">// Assemble vector of weights</span></div>
<div class="line">std::vector&lt;double&gt; weights; var.push_back(1), vars.push_back(2);</div>
<div class="line"><span class="comment">// Construct mixture</span></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> Y = sbb::mix(weights, vars);</div>
</div><!-- fragment --><p> In the example above, the random process <img class="formulaInl" alt="$Y$" src="form_14.png"/> will select the outcome of <img class="formulaInl" alt="$X_1$" src="form_2.png"/> with a probability of <img class="formulaInl" alt="$\frac{1}{3}$" src="form_32.png"/> and the outcome of <img class="formulaInl" alt="$X_2$" src="form_3.png"/> with probability <img class="formulaInl" alt="$\frac{2}{3}$" src="form_33.png"/>.</p>
<h2><a class="anchor" id="apicomp"></a>
Compound random variables</h2>
<p>An important class of derived random processes are compound proceses. There the parameters of the distribution of a random variable are themselfs random variables. That is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ X \sim f(x|A)\,,\quad A \sim g(a|\theta)\,, \]" src="form_42.png"/>
</p>
<p> where the random variable <img class="formulaInl" alt="$X$" src="form_18.png"/> is distributed as <img class="formulaInl" alt="$f(x|A)$" src="form_43.png"/>, parametrized by <img class="formulaInl" alt="$A$" src="form_44.png"/>, where <img class="formulaInl" alt="$A$" src="form_44.png"/> itself is a random variable distributed as <img class="formulaInl" alt="$g(a|\theta)$" src="form_45.png"/>, parametrized by <img class="formulaInl" alt="$\theta$" src="form_41.png"/>. Compound random variables are created using factory methods provided by the <code><a class="el" href="classsbb_1_1_compound.html" title="Represents a compound of random variables. ">sbb::Compound</a></code> class. For example, the <code><a class="el" href="classsbb_1_1_compound.html#ae14e338b05edb0e01a40bd6c9918c206" title="Constructs a compound random variable from a normal distribution where  and  are given by the specifi...">sbb::Compound::norm</a></code> factory method constructs a compount-normal distributed random variable, where both the mean and the standard deviation can by any other random variable. For example </p><div class="fragment"><div class="line">*  #include &lt;stochbb/api.hh&gt;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesbb.html">sbb</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> mu = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(10,100);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> sigma = <a class="code" href="classsbb_1_1_atomic_var.html#a58a2f93ef5a5be30abb569f96c42dc42">AtomicVar::delta</a>(10);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> cnorm = <a class="code" href="classsbb_1_1_compound.html#ae14e338b05edb0e01a40bd6c9918c206">Compound::norm</a>(mu, sigma);</div>
</div><!-- fragment --><p> instantiates a compound-normal distributed random variable, where the mean is gamma-distributed while the standard deviation is fixed (implemented by a delta distribution).</p>
<h1><a class="anchor" id="apisample"></a>
Sample random variables</h1>
<p>As mentioned above, sampling from a complex process efficiently is not trivial. First of all, is must be ensured that all atomic random variables are samples only once. Otherwise, two dependent random variables may be sampled as independent. Moreover, the results of derived random variables should be chached for efficiency. StochBB provides a separate class that implements a proper sampler for a system of random processes, the <code><a class="el" href="classsbb_1_1_exact_sampler.html" title="Implements a sampler for several possibly dependent random variables. ">sbb::ExactSampler</a></code> class. This class allows to sample from several possibly depdendent random variables simultaneously. Upon construction, the set of random variables to sample is specified. A sample from these random variables can then be obtained by the <code><a class="el" href="classsbb_1_1_exact_sampler.html#ac06b6af2b7fa6607522c11117120e588" title="Samples from the random variables passed to the constructor. ">sbb::ExactSampler::sample</a></code> method. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stochbb/api.hh&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesbb.html">sbb</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X1 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(10,100);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X2 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(20, 50);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> Y = std::min(X1, X2);</div>
<div class="line"><span class="comment">// Assemble vector of variables</span></div>
<div class="line">std::vector&lt;Var&gt; vars; vars.push_back(X1), vars.push_back(X2); vars.push_back(Y);</div>
<div class="line"><span class="comment">// Construct sampler</span></div>
<div class="line"><a class="code" href="classsbb_1_1_exact_sampler.html">ExactSampler</a> sampler(vars);</div>
<div class="line"><span class="comment">// Get 1000 samples</span></div>
<div class="line">Eigen::MatrixXd samples(3, 1000);</div>
<div class="line">sampler.sample(samples);</div>
</div><!-- fragment --><p> The <code><a class="el" href="classsbb_1_1_exact_sampler.html#ac06b6af2b7fa6607522c11117120e588" title="Samples from the random variables passed to the constructor. ">sbb::ExactSampler::sample</a></code> method takes a single <code>Eigen::Matrix</code> where each column represents the random variable given to the constructor and each row an independent sample.</p>
<p>For very large systems, sampling may become pretty slow. Particularily if one is only interested in the marignal distribution of single random variables. For these cases a approximative sampler for single random variables is provided, the <code><a class="el" href="classsbb_1_1_marginal_sampler.html" title="Implements an approximative marginal sampler for a sinlge random variable. ">sbb::MarginalSampler</a></code>. This sampler uses an approximation of the inverse of the cummulative distribution function of a random variable to draw samples. </p><div class="fragment"><div class="line">*  #include &lt;stochbb/api.hh&gt;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesbb.html">sbb</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// [...]</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X1 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(10,100);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> X2 = <a class="code" href="classsbb_1_1_atomic_var.html#a0da8f9da2542518b8fb42fe1d8f7a480">AtomicVar::gamma</a>(20, 50);</div>
<div class="line"><a class="code" href="classsbb_1_1_var.html">Var</a> Y = std::min(X1, X2);</div>
<div class="line"><span class="comment">// Sample from Y on [0,500] in 1000 steps</span></div>
<div class="line"><a class="code" href="classsbb_1_1_marginal_sampler.html">MarginalSampler</a> sampler(Y, 0, 500, 1000);</div>
<div class="line"><span class="comment">// Get 1000 samples</span></div>
<div class="line">Eigen::VectorXd samples(1000);</div>
<div class="line">sampler.sample(samples);</div>
</div><!-- fragment --><p> In this example, a <code>MarginalSampler</code> is constructed for the random variable Y. Using an approximation of its CDF on the interval <img class="formulaInl" alt="$[0,500)$" src="form_34.png"/> using 1000 steps. Then, the <code><a class="el" href="classsbb_1_1_marginal_sampler.html#a8dd68011e4ee93ea3ad7b02b6c6072af" title="Samples from the marginal. ">sbb::MarginalSampler::sample</a></code> method is used to obtain a sample. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 6 2015 23:18:14 for libstochbb - Stochastic Building Blocks by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
